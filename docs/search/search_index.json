{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AIOCLI A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test. Requirements Python 3.6+ Installation python3 -m pip install aiocli Example from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application () def _get_envs () -> dict [ str , str ]: return { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } def _get_logger ( envs : dict [ str , str ] = Depends ( _get_envs )) -> Logger : logger = getLogger ( envs [ 'LOGGER_NAME' ]) logger . setLevel ( envs [ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app ) License MIT","title":"aioddd"},{"location":"#aiocli","text":"A modern, lightweight, async console runner for building CLIs with Python 3.6+ based on standard Python's argparse module and type hints highly inspired by AIOHTTP and FastApi . Key Features: Native-based : Based on (and fully compatible with) Python's argparse module. Async support : Handle commands completely async thinking in smaller and larger apps. Serverless support : Wrappers for AWS Lambda , Azure Function and Google Cloud Function . Test support : Designed to be easy to execute and test.","title":"AIOCLI"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"python3 -m pip install aiocli","title":"Installation"},{"location":"#example","text":"from logging import getLogger , Logger , StreamHandler from os import getenv from aiocli.commander import run_app , Application , Depends app = Application () def _get_envs () -> dict [ str , str ]: return { 'LOGGER_NAME' : str ( getenv ( 'LOGGER_NAME' , 'example_app' )), 'LOGGER_LEVEL' : str ( getenv ( 'LOGGER_LEVEL' , 'INFO' )), } def _get_logger ( envs : dict [ str , str ] = Depends ( _get_envs )) -> Logger : logger = getLogger ( envs [ 'LOGGER_NAME' ]) logger . setLevel ( envs [ 'LOGGER_LEVEL' ]) handler = StreamHandler () logger . addHandler ( handler ) return logger @app . command ( name = 'greet:to' , positionals = [( '--name' , { 'default' : 'World!' })]) async def handle_greeting ( name : str , logger : Logger = Depends ( _get_logger )) -> int : logger . info ( f 'Hello { name } ' ) return 0 @app . command ( name = 'div' , optionals = [( '--a' , { 'type' : float }), ( '--b' , { 'type' : float })]) async def handle_division ( a : float , b : float , logger : Logger = Depends ( _get_logger )) -> int : try : logger . info ( f 'Result { a } / { b } = { ( a / b ) } ' ) return 0 except BaseException as err : logger . error ( f 'Error: { err } ' ) return 1 # python3 main.py <command> <positionals> <optionals> if __name__ == '__main__' : run_app ( app )","title":"Example"},{"location":"#license","text":"MIT","title":"License"},{"location":"en/","text":"Async Python DDD utilities library Key Features: Aggregates : Aggregate & AggregateRoot ValueObjects : Id, Timestamp & StrDateTime CQRS : Command, CommandBus, SimpleCommandBus, Query, Response, QueryHandler, QueryBus & SimpleQueryBus EventSourcing : Event, EventMapper, EventPublisher, EventHandler, EventBus, SimpleEventBus & InternalEventPublisher Errors : raise_, BaseError, NotFoundError, ConflictError, BadRequestError, UnauthorizedError, ForbiddenError, UnknownError, IdInvalidError, TimestampInvalidError, DateTimeInvalidError, EventMapperNotFoundError, EventNotPublishedError, CommandNotRegisteredError & QueryNotRegisteredError DependencyInjection (\u26a0 will move it to another package): Container Tests : AsyncMock & mock Utils : get_env & get_simple_logger Requirements Python 3.6+ Installation python3 -m pip install aioddd Example from asyncio import get_event_loop from dataclasses import dataclass from typing import Type from aioddd import NotFoundError , \\ Command , CommandHandler , SimpleCommandBus , \\ Query , QueryHandler , OptionalResponse , SimpleQueryBus , Event _products = [] class ProductStored ( Event ): @dataclass class Attributes : ref : str attributes : Attributes class StoreProductCommand ( Command ): def __init__ ( self , ref : str ): self . ref = ref class StoreProductCommandHandler ( CommandHandler ): def subscribed_to ( self ) -> Type [ Command ]: return StoreProductCommand async def handle ( self , command : StoreProductCommand ) -> None : _products . append ( command . ref ) class ProductNotFoundError ( NotFoundError ): _code = 'product_not_found' _title = 'Product not found' class FindProductQuery ( Query ): def __init__ ( self , ref : str ): self . ref = ref class FindProductQueryHandler ( QueryHandler ): def subscribed_to ( self ) -> Type [ Query ]: return FindProductQuery async def handle ( self , query : FindProductQuery ) -> OptionalResponse : if query . ref != '123' : raise ProductNotFoundError . create ( detail = { 'ref' : query . ref }) return { 'ref' : query . ref } async def main () -> None : commands_bus = SimpleCommandBus ([ StoreProductCommandHandler ()]) await commands_bus . dispatch ( StoreProductCommand ( '123' )) query_bus = SimpleQueryBus ([ FindProductQueryHandler ()]) response = await query_bus . ask ( FindProductQuery ( '123' )) print ( response ) if __name__ == '__main__' : get_event_loop () . run_until_complete ( main ()) License MIT WIP","title":"Async Python DDD utilities library"},{"location":"en/#async-python-ddd-utilities-library","text":"Key Features: Aggregates : Aggregate & AggregateRoot ValueObjects : Id, Timestamp & StrDateTime CQRS : Command, CommandBus, SimpleCommandBus, Query, Response, QueryHandler, QueryBus & SimpleQueryBus EventSourcing : Event, EventMapper, EventPublisher, EventHandler, EventBus, SimpleEventBus & InternalEventPublisher Errors : raise_, BaseError, NotFoundError, ConflictError, BadRequestError, UnauthorizedError, ForbiddenError, UnknownError, IdInvalidError, TimestampInvalidError, DateTimeInvalidError, EventMapperNotFoundError, EventNotPublishedError, CommandNotRegisteredError & QueryNotRegisteredError DependencyInjection (\u26a0 will move it to another package): Container Tests : AsyncMock & mock Utils : get_env & get_simple_logger","title":"Async Python DDD utilities library"},{"location":"en/#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"en/#installation","text":"python3 -m pip install aioddd","title":"Installation"},{"location":"en/#example","text":"from asyncio import get_event_loop from dataclasses import dataclass from typing import Type from aioddd import NotFoundError , \\ Command , CommandHandler , SimpleCommandBus , \\ Query , QueryHandler , OptionalResponse , SimpleQueryBus , Event _products = [] class ProductStored ( Event ): @dataclass class Attributes : ref : str attributes : Attributes class StoreProductCommand ( Command ): def __init__ ( self , ref : str ): self . ref = ref class StoreProductCommandHandler ( CommandHandler ): def subscribed_to ( self ) -> Type [ Command ]: return StoreProductCommand async def handle ( self , command : StoreProductCommand ) -> None : _products . append ( command . ref ) class ProductNotFoundError ( NotFoundError ): _code = 'product_not_found' _title = 'Product not found' class FindProductQuery ( Query ): def __init__ ( self , ref : str ): self . ref = ref class FindProductQueryHandler ( QueryHandler ): def subscribed_to ( self ) -> Type [ Query ]: return FindProductQuery async def handle ( self , query : FindProductQuery ) -> OptionalResponse : if query . ref != '123' : raise ProductNotFoundError . create ( detail = { 'ref' : query . ref }) return { 'ref' : query . ref } async def main () -> None : commands_bus = SimpleCommandBus ([ StoreProductCommandHandler ()]) await commands_bus . dispatch ( StoreProductCommand ( '123' )) query_bus = SimpleQueryBus ([ FindProductQueryHandler ()]) response = await query_bus . ask ( FindProductQuery ( '123' )) print ( response ) if __name__ == '__main__' : get_event_loop () . run_until_complete ( main ())","title":"Example"},{"location":"en/#license","text":"MIT","title":"License"},{"location":"en/#wip","text":"","title":"WIP"},{"location":"es/","text":"Librer\u00eda de utilidades Async Python de DDD \u00bfQu\u00e9 ofrece?: Aggregates : Aggregate & AggregateRoot ValueObjects : Id, Timestamp & StrDateTime CQRS : Command, CommandBus, SimpleCommandBus, Query, Response, QueryHandler, QueryBus & SimpleQueryBus EventSourcing : Event, EventMapper, EventPublisher, EventHandler, EventBus, SimpleEventBus & InternalEventPublisher Errors : raise_, BaseError, NotFoundError, ConflictError, BadRequestError, UnauthorizedError, ForbiddenError, UnknownError, IdInvalidError, TimestampInvalidError, DateTimeInvalidError, EventMapperNotFoundError, EventNotPublishedError, CommandNotRegisteredError & QueryNotRegisteredError DependencyInjection (\u26a0 will move it to another package): Container Tests : AsyncMock & mock Utils : get_env & get_simple_logger Requisitos Python 3.6+ Instalaci\u00f3n python3 -m pip install aioddd Ejemplo from asyncio import get_event_loop from dataclasses import dataclass from typing import Type from aioddd import NotFoundError , \\ Command , CommandHandler , SimpleCommandBus , \\ Query , QueryHandler , OptionalResponse , SimpleQueryBus , Event _products = [] class ProductStored ( Event ): @dataclass class Attributes : ref : str attributes : Attributes class StoreProductCommand ( Command ): def __init__ ( self , ref : str ): self . ref = ref class StoreProductCommandHandler ( CommandHandler ): def subscribed_to ( self ) -> Type [ Command ]: return StoreProductCommand async def handle ( self , command : StoreProductCommand ) -> None : _products . append ( command . ref ) class ProductNotFoundError ( NotFoundError ): _code = 'product_not_found' _title = 'Product not found' class FindProductQuery ( Query ): def __init__ ( self , ref : str ): self . ref = ref class FindProductQueryHandler ( QueryHandler ): def subscribed_to ( self ) -> Type [ Query ]: return FindProductQuery async def handle ( self , query : FindProductQuery ) -> OptionalResponse : if query . ref != '123' : raise ProductNotFoundError . create ( detail = { 'ref' : query . ref }) return { 'ref' : query . ref } async def main () -> None : commands_bus = SimpleCommandBus ([ StoreProductCommandHandler ()]) await commands_bus . dispatch ( StoreProductCommand ( '123' )) query_bus = SimpleQueryBus ([ FindProductQueryHandler ()]) response = await query_bus . ask ( FindProductQuery ( '123' )) print ( response ) if __name__ == '__main__' : get_event_loop () . run_until_complete ( main ()) Licencia MIT WIP","title":"Librer\u00eda de utilidades Async Python de DDD"},{"location":"es/#libreria-de-utilidades-async-python-de-ddd","text":"\u00bfQu\u00e9 ofrece?: Aggregates : Aggregate & AggregateRoot ValueObjects : Id, Timestamp & StrDateTime CQRS : Command, CommandBus, SimpleCommandBus, Query, Response, QueryHandler, QueryBus & SimpleQueryBus EventSourcing : Event, EventMapper, EventPublisher, EventHandler, EventBus, SimpleEventBus & InternalEventPublisher Errors : raise_, BaseError, NotFoundError, ConflictError, BadRequestError, UnauthorizedError, ForbiddenError, UnknownError, IdInvalidError, TimestampInvalidError, DateTimeInvalidError, EventMapperNotFoundError, EventNotPublishedError, CommandNotRegisteredError & QueryNotRegisteredError DependencyInjection (\u26a0 will move it to another package): Container Tests : AsyncMock & mock Utils : get_env & get_simple_logger","title":"Librer\u00eda de utilidades Async Python de DDD"},{"location":"es/#requisitos","text":"Python 3.6+","title":"Requisitos"},{"location":"es/#instalacion","text":"python3 -m pip install aioddd","title":"Instalaci\u00f3n"},{"location":"es/#ejemplo","text":"from asyncio import get_event_loop from dataclasses import dataclass from typing import Type from aioddd import NotFoundError , \\ Command , CommandHandler , SimpleCommandBus , \\ Query , QueryHandler , OptionalResponse , SimpleQueryBus , Event _products = [] class ProductStored ( Event ): @dataclass class Attributes : ref : str attributes : Attributes class StoreProductCommand ( Command ): def __init__ ( self , ref : str ): self . ref = ref class StoreProductCommandHandler ( CommandHandler ): def subscribed_to ( self ) -> Type [ Command ]: return StoreProductCommand async def handle ( self , command : StoreProductCommand ) -> None : _products . append ( command . ref ) class ProductNotFoundError ( NotFoundError ): _code = 'product_not_found' _title = 'Product not found' class FindProductQuery ( Query ): def __init__ ( self , ref : str ): self . ref = ref class FindProductQueryHandler ( QueryHandler ): def subscribed_to ( self ) -> Type [ Query ]: return FindProductQuery async def handle ( self , query : FindProductQuery ) -> OptionalResponse : if query . ref != '123' : raise ProductNotFoundError . create ( detail = { 'ref' : query . ref }) return { 'ref' : query . ref } async def main () -> None : commands_bus = SimpleCommandBus ([ StoreProductCommandHandler ()]) await commands_bus . dispatch ( StoreProductCommand ( '123' )) query_bus = SimpleQueryBus ([ FindProductQueryHandler ()]) response = await query_bus . ask ( FindProductQuery ( '123' )) print ( response ) if __name__ == '__main__' : get_event_loop () . run_until_complete ( main ())","title":"Ejemplo"},{"location":"es/#licencia","text":"MIT","title":"Licencia"},{"location":"es/#wip","text":"","title":"WIP"}]}